/**
 * @brief Version information
 */
const char Info_version[] = "AtomSim v2.0";

/**
 * @brief Copyright message
 */
const char Info_copyright[] = 
"MIT License\n\n"

"Copyright (c) 2020 Saurabh Singh\n\n"

"Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"of this software and associated documentation files (the \"Software\"), to deal\n"
"in the Software without restriction, including without limitation the rights\n"
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"copies of the Software, and to permit persons to whom the Software is\n"
"furnished to do so, subject to the following conditions:\n\n"

"The above copyright notice and this permission notice shall be included in all\n"
"copies or substantial portions of the Software.\n\n"

"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
"SOFTWARE.\n";

// ================== Color codes for output formatting ====================
const std::string  COLOR_RESET  = "\033[0m";
const std::string  COLOR_RED    =  "\033[31m";      
const std::string  COLOR_GREEN  =  "\033[32m";      
const std::string  COLOR_YELLOW =  "\033[33m";


// ================================ THROWING ERRORS =======================================
/**
 * @brief Throws error generated in the std::cerr stream
 * 
 * @param er_code error code 
 * @param message error message
 * @param exit flag that tells weather to exit immediately
 */
void throwError(std::string er_code, std::string message, bool Exit = false)
{
    std::cerr << COLOR_RED <<"! ERROR  (E"<< er_code <<"): " << COLOR_RESET << message << std::endl;
    if(Exit)
    {
        ExitAtomSim("", true);
    }
}


/**
 * @brief Throws warning generated by assembler in the std::cerr stream
 * 
 * @param wr_code warning code 
 * @param message Warning message
 */
void throwWarning(std::string wr_code, std::string message)
{
    std::cerr << COLOR_YELLOW <<"! WARNING (W"<< wr_code <<"): " << COLOR_RESET << message << std::endl;
}


/**
 * @brief Displays a success message
 * 
 * @param message Success message
 */
void throwSuccessMessage(std::string message, bool Exit = false)
{
    std::cout << COLOR_GREEN <<"SUCCESS : " << COLOR_RESET  << message <<std::endl;
    if(Exit)
    {
        ExitAtomSim("");
    }
}


/**
 * @brief String stripping utility functions
 * 
 * @see https://www.techiedelight.com/trim-string-cpp-remove-leading-trailing-spaces/#:~:text=We%20can%20use%20combination%20of,functions%20to%20trim%20the%20string.
 */
const std::string WHITESPACE = " \n\r\t\f\v";


/**
 * @brief removes preceeding whitespaces in a string
 * 
 * @param s string
 * @return std::string 
 */
std::string lStrip(const std::string& s)
{
    size_t start = s.find_first_not_of(WHITESPACE);
    return (start == std::string::npos) ? "" : s.substr(start);
}


/**
 * @brief removes succeeding whitespaces in a string
 * 
 * @param s string
 * @return std::string 
 */
std::string rStrip(const std::string& s)
{
    size_t end = s.find_last_not_of(WHITESPACE);
    return (end == std::string::npos) ? "" : s.substr(0, end + 1);
}


/**
 * @brief removes preceding & succeeding whitespaces in a string
 * 
 * @param s string
 * @return std::string 
 */
std::string strip(const std::string& s)
{
    return rStrip(lStrip(s));
}


// =============================== STRING TOKENIZING =====================================
/**
 * @brief splits a string accordint to delimiter 
 * 
 * @param txt input string
 * @param strs vector of strings parts
 * @param ch delimiter
 * @return size_t 
 */
size_t tokenize(const std::string &txt, std::vector<std::string> &strs, char ch)
{
    size_t pos = txt.find( ch );
    size_t initialPos = 0;
    strs.clear();

    // Decompose statement
    while( pos != std::string::npos ) {
        strs.push_back( txt.substr( initialPos, pos - initialPos ) );
        initialPos = pos + 1;

        pos = txt.find( ch, initialPos );
    }

    // Add the last one
    strs.push_back( txt.substr( initialPos, std::min( pos, txt.size() ) - initialPos + 1 ) );

    return strs.size();
}

// =============================== FILE READER =====================================
/**
 * @brief reads a binary file
 * 
 * @param memfile filepath
 * @return std::vector<char> contents
 */
std::vector<char> fReadBin(std::string memfile)
{        
    std::vector<char> fcontents;
    std::ifstream f (memfile, std::ios::out | std::ios::binary);
    
    if(!f)
    {
        throw "file access failed";
    }
    try
    {
        while(!f.eof())
        {    
            char byte;
            f.read((char *) &byte, 1);
            fcontents.push_back(byte);
        }
    }
    catch(...)
    {
        throw "file reading failed!";
    }
    f.close();
    return fcontents;
}


/**
 * @brief Reads a file and returns its contents
 * 
 * @param filepath Filepath
 * @return Vector of strings containing file contents
 */
std::vector<std::string> fRead (std::string filepath)
{
    // returns a vector of strings
    std::vector<std::string> text;

    // input file stream
    std::ifstream fin(filepath.c_str());
    if(!fin){
        throw "file access failed";
    }

    // reading file line by line and appending into the vector of strings
    std::string raw_line;
    while(getline(fin,raw_line))
    {
        text.push_back(raw_line);
    }

    // close file
    fin.close();
    return text;
}


// =================================== FILE WRITER ====================================
/**
 * @brief Write to a file
 * 
 * @param filepath Filepath
 */
void fWrite (std::vector<std::string> data, std::string filepath)
{
    std::ofstream File(filepath);
    if(!File)
    {
        throw "file writing failed";
    }
    for(unsigned int i=0; i<data.size(); i++)
    {
        File << data[i] <<"\n";
    }
    File.close();
}

// ================================ Runtime disassembly =================================
/**
 * @brief Get the Stdout From shell Command
 * 
 * @param cmd shell command to execute
 * @param get_output if true, returns stdout, else moves on(even if command isn't still complete)
 * @return std::string command output
 */
std::string GetStdoutFromCommand(std::string cmd, bool get_output = true) {

  std::string data;
  FILE * stream;
  const int max_buffer = 256;
  char buffer[max_buffer];
  cmd.append(" 2>&1");

  stream = popen(cmd.c_str(), "r");

  if (get_output && stream) {
    while (!feof(stream))
      if (fgets(buffer, max_buffer, stream) != NULL) data.append(buffer);
    pclose(stream);
  }
  return data;
}

struct DisassembledLine
{
    uint32_t instr;
    std::string disassembly;
};

/**
 * @brief Get the Disassembly of input file using riscv objdump
 * 
 * @param filename input filename
 * @return std::map<uint32_t, std::string> map of disassembly
 */
std::map<uint32_t, DisassembledLine> getDisassembly(std::string filename)
{
	std::string command = "";
	#ifdef RV32_COMPILER
		command +="riscv32-unknown-elf-objdump -d ";
	#else
		command += "riscv64-unknown-elf-objdump -d ";
	#endif
	command+=filename;
	
	// Get command output
	std::string output = GetStdoutFromCommand(command);
	
	std::stringstream s(output);

	// Parse command output
	std::map<uint32_t, DisassembledLine> dis;
	
	std::string line;
	while(std::getline(s, line))
	{        
        if(strip(line).length() == 0)
            continue;

        if(!(line.back() == ':' || line[0] != ' '))
        {
    
            line = strip(line);
            unsigned int colonAt = line.find(':');

            uint32_t addr = std::stoi(strip(line.substr(0, colonAt)), 0, 16);
            DisassembledLine d;
            d.instr = (uint32_t)std::stol(strip(line.substr(colonAt+1, colonAt+15)), 0, 16);
            d.disassembly = strip(line.substr(colonAt+16));

            dis.insert({addr, d});
        }
	}
	return dis;
}


/**
 * @brief Vuart Module
 * Encapsulates the functionality of a virtual uart port with the help of the a modified version of 
 * the CppLinuxSerial Library. The library has been modified to use only a 1 byte recieve buffer in 
 * order to enable character by character send/recieve rather than string by string.
 * @see https://github.com/gbmhunter/CppLinuxSerial
 * 
 */
class Vuart
{
    private:
    /**
     * @brief pointer to the serial port object
     */
    mn::CppLinuxSerial::SerialPort * port;

    /**
     * @brief Serial port Baudrate
     */
    mn::CppLinuxSerial::BaudRate port_baudrate;

    /**
     * @brief current state of the port
     */
    bool isopen = false;

    public:
    /**
     * @brief Construct a new Vuart object
     * 
     * @param portname name of the port
     * @param baud baudrate
     */
    Vuart(std::string portname, int baud=9600)
    {
        // set baud rate
        setbaud(baud);

        // create a new port object
        try
        {
            port = new mn::CppLinuxSerial::SerialPort(portname, port_baudrate);
        }
        catch(const mn::CppLinuxSerial::Exception& e)
        {
            throwError("VUART", e.what(), true);
        }

        /* Set timeout to 0: i.e. Non blocking Mode
            This (paired with 1 byte recieve buffer of the library) enables the latest pressed key 
            on the keyboard to be returned while calling recieve().
        */
        port->SetTimeout(0);

        // Open port
        openPort(true);
    }


    /**
     * @brief Destroy the Vuart object
     */
    ~Vuart()
    {
        // close port
        closePort(true);

        // destroy port object
        delete port;
    }


    /**
     * @brief set baud rate
     * 
     * @param baud 
     */
    void setbaud(unsigned int baud=9600)
    {
        switch(baud)
        {
            case 9600:
                port_baudrate=mn::CppLinuxSerial::BaudRate::B_9600; break;
            case 19200:
                port_baudrate=mn::CppLinuxSerial::BaudRate::B_19200; break;
            case 115200:
                port_baudrate=mn::CppLinuxSerial::BaudRate::B_115200; break;
            
            default:
                throwError("VPORT_BAUD", "INVALID BAUD RATE: "+std::to_string(baud), true);
                return;
        }

        // if already opened
        if(isopen)
        {
            // Close port, change baudrate, and reopen
            closePort(true);

            port->SetBaudRate(port_baudrate);
            
            openPort(true);
        }
    }


    /**
     * @brief Get currently used baudrate
     * 
     * @return int baudrate
     */
    unsigned int getbaud()
    {
        switch(port_baudrate)
        {
            case mn::CppLinuxSerial::BaudRate::B_9600:
                return 9600;
            case mn::CppLinuxSerial::BaudRate::B_19200:
                return 19200;
            case mn::CppLinuxSerial::BaudRate::B_115200:
                return 115200;
            
            default: 
                return -1;  // unknown baud
        }
    }

    /**
     * @brief Returns current state of the port
     * 
     * @return true if open 
     * @return false if closed
     */
    bool isOpen()
    {
        return isopen;
    }


    /**
     * @brief Send a charactr to uvart
     * 
     * @param c character
     */
    void send(char c)
    {
        std::vector<uint8_t> vec;
        vec.push_back((uint8_t) c);
        port->WriteBinary(vec);
    }


    /**
     * @brief Immediately returns the char present in the recieve buffer
     *        if no chr present returns 255 i.e. -1
     * 
     * @return char character
     */
    char recieve()
    {        
        std::vector<uint8_t> vec;
        port->ReadBinary(vec);

        if(vec.size()==0)
            return -1;
        else
            return (char) vec[0];
    }


    /**
     * @brief Cleans the 1 bit recieve buffer for any garbage
     */
    void clean_recieve_buffer()
    {
        char c;
        do
        {
            c = recieve();  // dump garbage
        } while(c != -1);
    }

    // Helper functions
    private:
    inline void openPort(bool verbose=true)
    {
        port->Open();
        isopen = true;

        if(verbose)
            port->Write("\r\nVuart::Atomsim connected! (baud:"+std::to_string(getbaud())+")\r\n");
    }

    inline void closePort(bool verbose=true)
    {
        if(verbose)
            port->Write("\r\nVuart::Atomsim disconnected!\r\n");

        port->Close();
        isopen = false;
    }
};